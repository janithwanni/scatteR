library(palmerpenguins)
library(tidyverse)
library(scatteR)
library(parallel)

check_synthesis <- function(data){
  cl <- makeCluster(getOption("cl.cores", 2))
  on.exit(stopCluster(cl))
  cols <- colnames(data %>% select_if(is.numeric))
  results <- expand_grid(X = cols, Y = cols) %>%
    filter(X != Y)
  exp_tib <- parApply(cl,results,1, function(row){
    x <- row[1] |> unlist()
    y <- row[2] |> unlist()
    factors <- which(length(data[[x]]) %% seq(1,length(data[[x]])) == 0)
    d <- scatteR::scatteR(scagnostics::scagnostics(data[[x]],data[[y]]),
                          n_points = length(data[[x]]),
                          init_points = factors[floor(quantile(seq(length(factors)),0.75))],epochs = 200)
    destd_x <- (d$x * (max(data[[x]])-min(data[[x]]))) + min(data[[x]])
    destd_y <- (d$y * (max(data[[y]])-min(data[[y]]))) + min(data[[y]])
    d$x <- destd_x
    d$y <- destd_y
    w <- transport::wasserstein(transport::pp(cbind(destd_x,destd_y)),
                                transport::pp(cbind(data[[x]],data[[y]])),p=2)
    return(list(scatter = d,wass_dist = w))
  })
  gen <- imap_dfr(exp_tib, function(ls,ind){
    ls$scatter |> mutate(comb = ind,
                         comb_x = results[ind,"X"] |> unlist(),
                         comb_y = results[ind,"Y"] |> unlist())
    })
  synth_data <- gen %>% group_by(comb_y,comb_x) %>%
    mutate(rank_y = rank(y)) %>%
    ungroup() %>%
    group_by(comb_y,rank_y) %>%
    summarize(value = median(y,na.rm=T)) %>%
    ungroup() %>%
    rename(c("variable"="comb_y")) %>%
    mutate(origin = "y") %>%
    select(variable,value,origin) %>%
    bind_rows(
      gen %>% group_by(comb_x,comb_y) %>%
        mutate(rank_x = rank(x)) %>%
        ungroup() %>%
        group_by(comb_x,rank_x) %>%
        summarize(value = median(x,na.rm=T)) %>%
        ungroup() %>%
        rename(c("variable"="comb_x")) %>%
        mutate(origin = "x") %>%
        select(variable,value,origin)
    ) %>%
    group_by(variable,origin) %>%
    mutate(rank_val = rank(value)) %>%
    ungroup() %>%
    group_by(variable,rank_val) %>%
    summarize(value = median(value,na.rm=T)) %>%
    pivot_wider(id_cols = rank_val,names_from = variable,values_from  = value) %>%
    select(-rank_val)

  results <- results %>% mutate(distance = map_dbl(exp_tib,~.x$wass_dist))
  return(list(results = results,gen = gen,synth_data = synth_data))
}

mtcars %>% pivot_longer(cols = c("cyl","disp","mpg"),names_to = "var",values_to = "val") %>% ggplot(aes(x = val)) + geom_histogram() + facet_wrap(~ var,scales="free")

mtsynth <- check_synthesis(mtcars[,1:4])
mtsynth$results %>%
  ggplot(aes(x = X,y = Y,fill = distance))+
  geom_tile()+
  geom_label(aes(label = round(distance,2)),color="white")+
  theme_minimal()

penguinsynth <- check_synthesis(penguins %>% drop_na() %>% select(-year))
penguinsynth %>%
  ggplot(aes(x = X,y = Y,fill = distance))+
  geom_tile()+
  geom_label(aes(label = round(distance,2)),color="white")+
  theme_minimal() +
  labs(title = "Wasserstein distance metrics for synthetic bivariate data generated by scatteR",subtitle = "Original number of data points were synthesized",x = "Variable 1",y = "Variable 2",fill = "Distance")

# no_cores <- detectCores() - 1 #it is recomendable that you use the number of cores less one



# results <- expand_grid(X = cols, Y = cols) %>%
#   filter(X != Y)
#
# exp_tib <- parApply(cl,results,1, function(row){
#     x <- row[1]
#     y <- row[2]
#     # paste(x,y)
#     d <- scatteR::scatteR(scagnostics::scagnostics(palmerpenguins::penguins[[x]],
#                                                    palmerpenguins::penguins[[y]]))
#     transport::wasserstein1d(d$x,d$y)
# })
#
# cols <- colnames(mtcars %>% select_if(is.numeric))
#
# results <- expand_grid(X = cols, Y = cols) %>%
#   filter(X != Y)
#
#
theme_set(theme_minimal())
library(GGally)
scat_mat <- ggpairs(mtcars %>% select_if(is.numeric) %>% drop_na(),
                    upper = list(continuous = mod_point,combo = mod_dot),lower = list(continuous = mod_point,combo = mod_dot))

# for(i in 1:11) {
#   for(j in 1:11){
#     scat_mat[i,j] <- scat_mat[i,j] +
#       scale_color_manual(values = "white")
#   }
# }

# modified_density = function(data, mapping, ...) {
#
#   ggally_densityDiag(data, mapping, ...) + scale_fill_brewer(type = "qual", palette = "Set3")
# }
mod_point <- function(data,mapping, ...){
  x_str <- rlang::as_name(mapping$x)
  y_str <- rlang::as_name(mapping$y)
  data_cols <- colnames(data)
  results <- expand_grid(X = data_cols, Y = data_cols) %>%
    filter(X != Y)
  results$colors <- colors()[seq.int(10,650,length.out = nrow(results))]
  ggally_autopoint(data,mapping,
                   color = results[results$X == x_str & results$Y == y_str,"colors"][1] |> unlist(), ...)
}
mod_dot <- function(data,mapping,...){
  x_str <- rlang::as_name(mapping$x)
  y_str <- rlang::as_name(mapping$y)
  data_cols <- colnames(data)
  results <- expand_grid(X = data_cols, Y = data_cols) %>%
    filter(X != Y)
  results$colors <- colors()[seq.int(10,650,length.out = nrow(results))]
  ggally_dot_no_facet(data,mapping,color = results[results$X == x_str & results$Y == y_str,"colors"][1] |> unlist(),...)
}

# ggpairs(iris, columns = 1:3,  aes(color = Species),
#         diag = list(continuous = modified_density))

ggpairs(iris, columns = 1:3,upper = list(continuous = mod_point,combo = mod_dot),lower = list(continuous = mod_point,combo = mod_dot))

penscag <- scagnostics::scagnostics(penguins %>% select_if(is.numeric) %>% drop_na())

penscag[,] |> t() |> as_tibble() |>
  GGally::ggpairs(upper = list(continuous = mod_point,combo = mod_dot),lower = list(continuous = mod_point,combo = mod_dot))
